# Go 指南

## 包

每个 Go 程序都是由**包**构成的。

程序从 `main` 包开始运行。

本程序通过导入路径 `"fmt"` 和 `"math/rand"` 来使用这两个包。

按照约定，**包名与导入路径的最后一个元素一致**。例如，`"math/rand"` 包中的源码均以 `package rand` 语句开始。

```go
package main
import (
	"fmt"
    "math/rand"
)

func main() {
    fmt.Println('number is ', rand.Intn(10))
}
```

### 包声明

- 语法形式：package xxxx

- 字母和下划线组合
- 可以和文件夹不同名字
- 同一文件夹下的声明一致

## 导入

此代码用圆括号组合了导入，这是“分组”形式的导入语句。

当然你也可以编写多个导入语句

```go
import (
	"fmt"
	"math"
)

import "fmt"
import "math"
```

匿名引用 _

```go
import _ "fmt" // _ 匿名引用，执行包的 init方法
```



## 导出名

在 Go 中，如果一个名字以大写字母开头，那么它就是已导出的。例如，`Pizza` 就是个已导出名，`Pi` 也同样，它导出自 `math` 包。

`pizza` 和 `pi` 并未以大写字母开头，所以它们是未导出的。

```
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Println(math.Pi)
}
```



## 函数

函数可以没有参数或接受多个参数。

在本例中，`add` 接受两个 `int` 类型的参数。

注意类型在变量名 **之后**。

```go
package main

import "fmt"

func add(x int, y int) int {
	return x + y
}

func main() {
    fmt.Println(add(x, y))
}
```

当**连续**两个或多个函数的已命名**形参类型相同**时，除最后一个类型以外，其它都可以**省略**。

```go
x int, y int
x, y int
```



## 多值返回

函数可以返回任意数量的返回值。

```go
func swap(x, y string) (string, string) {
    return y, x
}
```



## 命名返回值

Go 的**返回值可被命名**，它们会被视作定义在**函数顶部的变量**。

**返回值的名称**应当**具有**一定的**意义**，它可以作为**文档**使用。

没有参数的 `return` 语句返回已命名的返回值。也就是 `直接` 返回。

直接返回语句应当仅用在下面这样的短函数中。在长的函数中它们会影响代码的可读性。

```go
package main

import "fmt"

func split(sum int) (x, y int) {
    x = sum * 4 / 9
    y = sum - x
    return
}

func main() {
    fmt.Println(split(17))
}
```



## 变量

`var` 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后。

就像在这个例子中看到的一样，`var` 语句可以出现在包或函数级别。

```go
var c, python, java bool
```

**易错点**

- 变量声明了没有使用
- 类型不匹配
- 同作用域下，变量只能声明一次

## 变量的初始化

变量声明可以包含初始值，每个变量对应一个。

如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。



## 短变量声明(只能在函数内使用)

**在函数中**，简洁赋值语句 `:=` 可在类型明确的地方代替 `var` 声明。

函数外的每个语句都必须以关键字开始（`var`, `func` 等等），**因此 `:=` 结构不能在函数外使用**。



## 基本类型

Go 的基本类型有

```go
bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // uint8 的别名

rune // int32 的别名
    // 表示一个 Unicode 码点

float32 float64

complex64 complex128
```

本例展示了几种类型的变量。 同导入语句一样，变量声明也可以“分组”成一个语法块。

```go
var (
	ToBe   bool       = false
	MaxInt uint64     = 1<<64 - 1
	z      complex128 = cmplx.Sqrt(-5 + 12i)
)
```

`int`, `uint` 和 `uintptr` 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 `int` 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。



### string

- 双引号，内部使用双引号需要转义
- `引起来，内部使用该符号需要转义

### string长度

- 字节长度：与编码无关，len("str")
- 字符长度：与编码有关，用编码库来计算

### string主要方法

- ###### 查找和替换

- 大小写转换

- 子字符串相关

- 相等



### rune 类型

- rune，直观理解，就是字符
- rune 不是 byte
- rune 本质是 int32，一个rune是4个字节
- 不太常用



bool，int，uint，float

- bool: true, false
- int8,int16,int32 int64
- ...

### byte 类型

- byte 字节，本质 uint8
- 对应的操作包在 butes 上



## 零值

**没有明确初始值**的**变量**声明会被赋予它们的 **零值**。

零值是：

- 数值类型为 `0`，
- 布尔类型为 `false`，
- 字符串为 `""`（空字符串）。



## 类型转换

表达式 `T(v)` 将值 `v` 转换为类型 `T`。

一些关于数值的转换：

```
var i int = 42
var f float64 = float64(i)
var u uint = uint(f)
```

或者，更加简单的形式：

```
i := 42
f := float64(i)
u := uint(f)
```



## 类型推导

在声明一个**变量而不指定其类型**时（即使用不带类型的 `:=` 语法或 `var =` 表达式语法），**变量的类型由右值推导得出**。

**当右值声明了类型时，新变量的类型与其相同**：

```go
var i int
j := i // j 也是一个 int
```

不过**当右边包含未指明类型的数值常量**时，新变量的类型就可能是 `int`, `float64` 或 `complex128` 了，这取决于**常量的精度**：

```go
i := 42           // int
f := 3.142        // float64
g := 0.867 + 0.5i // complex128
```



## 常量

常量的声明与变量类似，只不过是使用 `const` 关键字。

常量可以是字符、字符串、布尔值或数值。

**常量不能用 `:=` 语法声明。**

```go
const Pi = 3.14
```



## 数值常量

数值常量是高精度的 **值**。

一个未指定类型的常量由上下文来决定其类型。



## for

##### Go 只有一种循环结构：`for` 循环。

基本的 `for` 循环由三部分组成，它们用分号隔开：

- 初始化语句：在第一次迭代前执行
- 条件表达式：在每次迭代前求值
- 后置语句：在每次迭代的结尾执行

```go
for i:=0; i<10; i++ {
    
}
```

初始化语句通常为一句短变量声明，该变量声明仅在 `for` 语句的作用域中可见。

一旦条件表达式的布尔值为 `false`，循环迭代就会终止。



##### for 可省略初始化语句和后置语句

- 初始化语句和后置语句是可选的。
- 此时可以去掉分号，相当于 while

```go
for ;sum<1000; {
	sum += sum
}

// 变式 while
for sum < 1000 {
    sum += sum
}
```



## 无限循环

如果省略循环条件，该循环就不会结束，因此无限循环可以写得很紧凑。

```go
for {
    
}
```



## if

Go 的 `if` 语句与 `for` 循环类似，表达式外无需小括号 `( )` ，而大括号 `{ }` 则是必须的。



## if 的简短语句

同 `for` 一样， `if` 语句可以在条件表达式前执行一个简单的语句。

该语句声明的变量作用域仅在 `if` 之内。

```go

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
		return v
	}

	return lim
}
```



## if 和 else

在 `if` 的简短语句中声明的变量同样可以在任何对应的 `else` 块中使用。



## switch

`switch` 是编写一连串 `if - else` 语句的简便方法。它运行第一个值等于条件表达式的 case 语句。

Go 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 **Go 只运行选定的 case，而非之后所有的 case**。 实际上，**Go 自动提供了在这些语言中每个 case 后面所需的 `break` 语句**。 除非**以 `fallthrough` 语句结束，否则分支会自动终止**。 Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。



## switch 的求值顺序

switch 的 case 语句从上到下顺次执行，直到匹配成功时停止。



## 没有条件的 switch

没有条件的 switch 同 `switch true` 一样。

这种形式能将一长串 if-then-else 写得更加清晰。

```go
t := time.Now()
switch {
case t.Hour() < 12:
	fmt.Println("Good morning!")
case t.Hour() < 17:
	fmt.Println("Good afternoon.")
default:
	fmt.Println("Good evening.")
}
```



## defer

defer 语句会将函数推迟到外层函数返回之后执行。

推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。



## defer 栈

推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。



## 指针

Go 拥有指针。指针保存了值的内存地址。

类型 `*T` 是指向 `T` 类型值的指针。其零值为 `nil`。

```
var p *int
```

`&` 操作符会生成一个指向其操作数的指针。

```
i := 42
p = &i
```

`*` 操作符表示指针指向的底层值。

```
fmt.Println(*p) // 通过指针 p 读取 i
*p = 21         // 通过指针 p 设置 i
```

这也就是通常所说的“间接引用”或“重定向”。



## 结构体

一个结构体（`struct`）就是一组字段（field）。



## 结构体字段

结构体字段使用点号来访问。

```go

import "fmt"

type Vertex struct {
	X int
	Y int
}

func jiegouti() {
	v := Vertex{1, 2}
	v.X = 4
	fmt.Println(v)
}
```



## 结构体指针

**结构体字段**可以通过**结构体指针**来访问。

如果我们有一个指向结构体的指针 `p`，那么可以通过 `(*p).X` 来访问其字段 `X`。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 `p.X` 就可以。

```go
func jiegouti() {
	v := Vertex{1, 2}
	v.X = 4
	p := &v
	p.Y = 3
	fmt.Println(v)
}
```



## 结构体文法

结构体文法通过直接列出字段的值来新分配一个结构体。

使用 `Name:` 语法可以仅列出部分字段。（字段名的顺序无关。）

特殊的前缀 `&` 返回一个指向结构体的指针。



## 数组

类型 `[n]T` 表示拥有 `n` 个 `T` 类型的值的数组。

表达式

```
var a [10]int
```

会将变量 `a` 声明为拥有 10 个整数的数组。

数组的长度是其类型的一部分，因此**数组不能改变大小**。这看起来是个限制，不过没关系，Go 提供了更加便利的方式来使用数组。



## 切片

每个**数组的大小都是固定的**。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。

类型 `[]T` 表示一个元素类型为 `T` 的切片。

切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：

```
a[low : high]
```

它会选择一个**半开区间**，**包括第一个元素**，但**排除最后一个元素**。

以下表达式创建了一个切片，它包含 `a` 中下标从 1 到 3 的元素：

```
a[1:4]
```



## 切片就像数组的引用

切片并不存储任何数据，它只是描述了底层数组中的一段。

更改切片的元素会修改其底层数组中对应的元素。

与它共享底层数组的切片都会观测到这些修改。



## 切片文法

切片文法类似于没有长度的数组文法。

这是一个数组文法：

```
[3]bool{true, true, false}
```

下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片：

```
[]bool{true, true, false}
```



## 切片的默认行为

在进行切片时，你可以利用它的默认行为来忽略上下界。

切片**下界**的默认值为 `0`，**上界**则是该切片的**长度**。

对于数组

```
var a [10]int
```

来说，以下切片是等价的：

```
a[0:10]
a[:10]
a[0:]
a[:]
```



## 切片的长度与容量

切片拥有 **长度** 和 **容量**。

切片的长度就是它所包含的元素个数。

切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。

切片 `s` 的长度和容量可通过表达式 `len(s)` 和 `cap(s)` 来获取。

你可以通过重新切片来扩展一个切片，给它提供足够的容量。试着修改示例程序中的切片操作，向外扩展它的容量，看看会发生什么。



## nil 切片

切片的零值是 `nil`。

nil 切片的长度和容量为 0 且没有底层数组。

## 用 make 创建切片

切片可以用内建函数 `make` 来创建，这也是你创建动态数组的方式。

`make` 函数会分配一个元素为零值的数组并返回一个引用了它的切片：

```
a := make([]int, 5)  // len(a)=5
```

要指定它的容量，需向 `make` 传入第三个参数：

```
b := make([]int, 0, 5) // len(b)=0, cap(b)=5

b = b[:cap(b)] // len(b)=5, cap(b)=5
b = b[1:]      // len(b)=4, cap(b)=4
```

## 切片的切片

切片可包含任何类型，甚至包括其它的切片。

## 向切片追加元素

为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 `append` 函数。内建函数的[文档](https://go-zh.org/pkg/builtin/#append)对此函数有详细的介绍。

```
func append(s []T, vs ...T) []T
```

`append` 的第一个参数 `s` 是一个元素类型为 `T` 的切片，其余类型为 `T` 的值将会追加到该切片的末尾。

`append` 的结果是一个包含原切片所有元素加上新添加元素的切片。

当 `s` 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。


## Range

`for` 循环的 `range` 形式可**遍历 ** **切片或映射**。

当使用 `for` 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。

```go
	for idx, val := range pow {
		fmt.Printf("2**%d = %v\n", idx, val)
	}
```

## range（续）

可以将下标或值赋予 `_` 来忽略它。

```
for i, _ := range pow
for _, value := range pow
```

若你只需要索引，忽略第二个变量即可。

```
for i := range pow
```